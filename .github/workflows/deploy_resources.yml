
name: HR Portal - Deploy Resources
on:
  workflow_call:
    inputs:
      action:
        description: 'Action to perform'
        type: string
        required: true
        default: 'deploy'
    outputs:
      ec2_ip:
        description: "EC2 instance public IP"
        value: ${{ jobs.deploy.outputs.ec2_ip }}
      api_url:
        description: "API Gateway URL"
        value: ${{ jobs.deploy.outputs.api_url }}
      alb_dns:
        description: "ALB DNS name"
        value: ${{ jobs.deploy.outputs.alb_dns }}
      instance_id:
        description: "EC2 instance ID"
        value: ${{ jobs.deploy.outputs.instance_id }}
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  deploy:
    if: ${{ inputs.action != 'destroy' }}
    runs-on: ubuntu-latest
    outputs:
      ec2_ip: ${{ steps.terraform_outputs.outputs.EC2_IP }}
      api_url: ${{ steps.terraform_outputs.outputs.API_URL }}
      alb_dns: ${{ steps.terraform_outputs.outputs.ALB_DNS }}
      instance_id: ${{ steps.terraform_outputs.outputs.INSTANCE_ID }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
          
      - name: Build Docker image
        run: |
          docker build -t hr-portal-app:latest .
          docker save hr-portal-app:latest > hr-portal-app.tar
        
      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -var="db_username=admin" -var="db_password=password123"
        
      - name: Terraform Apply
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          cd terraform
          terraform apply -auto-approve -var="db_username=admin" -var="db_password=password123"
          
      - name: Get infrastructure outputs
        if: ${{ github.ref == 'refs/heads/main' }}
        id: terraform_outputs
        run: |
          cd terraform
          EC2_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "unavailable")
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "unavailable")
          API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "unavailable")
          
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=hr-portal-ec2" --query "Reservations[0].Instances[0].InstanceId" --output text 2>/dev/null || echo "unavailable")
          
          echo "EC2_IP=${EC2_IP}" >> $GITHUB_OUTPUT
          echo "API_URL=${API_URL}" >> $GITHUB_OUTPUT
          echo "ALB_DNS=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "INSTANCE_ID=${INSTANCE_ID}" >> $GITHUB_OUTPUT
          
          echo "EC2 IP: ${EC2_IP}"
          echo "ALB DNS: ${ALB_DNS}"
          echo "API URL: ${API_URL}"
          echo "Instance ID: ${INSTANCE_ID}"
      
      - name: Wait for instance
        if: ${{ github.ref == 'refs/heads/main' && steps.terraform_outputs.outputs.INSTANCE_ID != 'unavailable' }}
        run: |
          INSTANCE_ID=${{ steps.terraform_outputs.outputs.INSTANCE_ID }}
          
          if [ "$INSTANCE_ID" == "unavailable" ]; then
            echo "Instance ID not available. Skipping instance wait step."
            exit 0
          fi
          
          echo "Waiting for instance $INSTANCE_ID to be fully initialized..."
          
          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          
          # Wait for SSM agent to be online
          MAX_ATTEMPTS=20
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Checking SSM status..."
            SSM_STATUS=$(aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$INSTANCE_ID" --query "InstanceInformationList[].PingStatus" --output text || echo "OFFLINE")
            
            if [ "$SSM_STATUS" == "Online" ]; then
              echo "SSM agent is online!"
              break
            fi
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "Max attempts reached but instance is still not ready. Continuing anyway..."
            fi
            
            echo "Instance not ready. Waiting 30 seconds..."
            sleep 30
          done
          
          # Additional wait for system services
          echo "Waiting an additional minute for all services to start..."
          sleep 60
      
      - name: Test instance connectivity
        if: ${{ github.ref == 'refs/heads/main' && steps.terraform_outputs.outputs.INSTANCE_ID != 'unavailable' }}
        run: |
          INSTANCE_ID=${{ steps.terraform_outputs.outputs.INSTANCE_ID }}
          
          if [ "$INSTANCE_ID" == "unavailable" ]; then
            echo "Instance ID not available. Skipping connectivity test."
            exit 0
          fi
          
          echo "Testing instance with simple SSM command..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=['echo \"SSM test successful\"', 'docker --version || amazon-linux-extras install -y docker', 'systemctl status docker || systemctl start docker']" \
            --comment "Testing SSM connectivity and Docker installation"
            
          sleep 15
      
      - name: Deploy application
        if: ${{ github.ref == 'refs/heads/main' && steps.terraform_outputs.outputs.INSTANCE_ID != 'unavailable' }}
        run: |
          INSTANCE_ID=${{ steps.terraform_outputs.outputs.INSTANCE_ID }}
          EC2_IP=${{ steps.terraform_outputs.outputs.EC2_IP }}
          if [ "$INSTANCE_ID" == "unavailable" ]; then
            echo "Instance ID not available. Skipping deployment."
            exit 0
          fi
          BUCKET_NAME="hr-portal-docker-temp-$(date +%s)"
          aws s3 mb s3://$BUCKET_NAME
          aws s3 cp hr-portal-app.tar s3://$BUCKET_NAME/
          echo "Deploying Docker container to EC2..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=[
              'echo \"Starting Docker deployment at $(date)\"',
              'aws s3 cp s3://$BUCKET_NAME/hr-portal-app.tar /tmp/',
              'docker load -i /tmp/hr-portal-app.tar',
              'docker stop hr-portal-container || true',
              'docker rm hr-portal-container || true',
              'docker run -d --name hr-portal-container -p 80:80 -e API_GATEWAY_ALLOW_ALL=true hr-portal-app:latest',
              'echo \"Docker container status:\"',
              'docker ps',
              'curl -s http://localhost || echo \"Could not connect to web server\"'
            ]" \
            --comment "Deploy HR Portal Docker container"
          aws s3 rm s3://$BUCKET_NAME/hr-portal-app.tar
          aws s3 rb s3://$BUCKET_NAME
