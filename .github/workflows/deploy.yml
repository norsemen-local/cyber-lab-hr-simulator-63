
name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
      
      - name: Check if environment is already deployed
        id: check_deployment
        run: |
          cd terraform
          # Use terraform state list to check if resources exist instead of output
          if terraform state list | grep -q "aws_instance.hr_portal_ec2"; then
            echo "Environment is already deployed"
            echo "already_deployed=true" >> $GITHUB_OUTPUT
            # Get outputs safely with error handling
            EC2_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "unavailable")
            API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "unavailable")
            echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
            echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
          else
            echo "Environment is not yet deployed"
            echo "already_deployed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Cancel deployment if already exists
        if: ${{ steps.check_deployment.outputs.already_deployed == 'true' && github.event.inputs.action != 'destroy' }}
        run: |
          echo "Infrastructure is already deployed."
          echo "EC2 Instance URL: http://${{ steps.check_deployment.outputs.EC2_IP || 'unavailable' }}"
          echo "API Gateway URL: ${{ steps.check_deployment.outputs.API_URL || 'unavailable' }}"
          echo "To destroy the infrastructure, run this workflow with the 'destroy' action."
          exit 0
          
      - name: Install dependencies
        if: ${{ github.event.inputs.action != 'destroy' && steps.check_deployment.outputs.already_deployed != 'true' }}
        run: npm ci
        
      - name: Build application
        if: ${{ github.event.inputs.action != 'destroy' && steps.check_deployment.outputs.already_deployed != 'true' }}
        run: npm run build
        
      - name: Terraform Plan
        if: ${{ github.event.inputs.action != 'destroy' && steps.check_deployment.outputs.already_deployed != 'true' }}
        run: |
          cd terraform
          terraform plan -var="db_username=admin" -var="db_password=password123"
        
      - name: Terraform Apply
        if: ${{ github.ref == 'refs/heads/main' && github.event.inputs.action != 'destroy' && steps.check_deployment.outputs.already_deployed != 'true' }}
        run: |
          cd terraform
          terraform apply -auto-approve -var="db_username=admin" -var="db_password=password123"
      
      - name: Terraform Destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        run: |
          cd terraform
          terraform destroy -auto-approve -var="db_username=admin" -var="db_password=password123"
          
      - name: Deploy application to EC2
        if: ${{ github.ref == 'refs/heads/main' && github.event.inputs.action != 'destroy' && steps.check_deployment.outputs.already_deployed != 'true' }}
        run: |
          # Get the public IP of the EC2 instance from Terraform output
          cd terraform
          EC2_IP=$(terraform output -raw ec2_public_ip)
          API_URL=$(terraform output -raw api_gateway_url)
          
          # Package the application
          cd ..
          tar -czf app.tar.gz dist
          
          # Copy files to EC2 using scp without key verification
          scp -o StrictHostKeyChecking=no app.tar.gz ec2-user@$EC2_IP:/home/ec2-user/
          
          # SSH into the instance and deploy without key verification
          ssh -o StrictHostKeyChecking=no ec2-user@$EC2_IP << 'EOF'
            mkdir -p /var/www/html
            tar -xzf app.tar.gz -C /var/www/html
            # Create database configuration with hardcoded credentials
            echo "db_config:" > /home/ec2-user/db_config.yaml
            echo "  username: admin" >> /home/ec2-user/db_config.yaml
            echo "  password: password123" >> /home/ec2-user/db_config.yaml
            echo "  host: $(aws rds describe-db-instances --db-instance-identifier hr-portal-db --query 'DBInstances[0].Endpoint.Address' --output text)" >> /home/ec2-user/db_config.yaml
            # Setup and start the application (simplified)
            sudo systemctl restart nginx
          EOF
          
          echo "Application deployed successfully!"
          echo "EC2 Instance URL: http://$EC2_IP"
          echo "API Gateway URL: $API_URL"
      
      - name: Display URLs for existing deployment
        if: ${{ steps.check_deployment.outputs.already_deployed == 'true' && github.event.inputs.action != 'destroy' }}
        run: |
          echo "Application is already deployed!"
          echo "EC2 Instance URL: http://${{ steps.check_deployment.outputs.EC2_IP || 'unavailable' }}"
          echo "API Gateway URL: ${{ steps.check_deployment.outputs.API_URL || 'unavailable' }}"
