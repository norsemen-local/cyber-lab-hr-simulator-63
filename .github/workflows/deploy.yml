
name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
      
      - name: Check for existing resources
        id: check_resources
        run: |
          # Check for existing resources by name to avoid duplicates
          echo "Checking for existing resources..."
          
          # Check for EC2 instance
          EC2_EXISTS=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=hr-portal-ec2" "Name=instance-state-name,Values=running,stopped,pending,stopping" --query "Reservations[*].Instances[*]" --output text | wc -l)
          
          # Check for RDS instance
          RDS_EXISTS=$(aws rds describe-db-instances --query "DBInstances[?DBInstanceIdentifier=='hr-portal-db'].DBInstanceIdentifier" --output text | wc -l)
          
          # Check for VPC
          VPC_EXISTS=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=hr-portal-vpc" --query "Vpcs[*].VpcId" --output text | wc -l)
          
          # Check for API Gateway
          API_EXISTS=$(aws apigateway get-rest-apis --query "items[?name=='hr-portal-api'].id" --output text | wc -l)
          
          # Output the results
          echo "EC2 instances found: $EC2_EXISTS"
          echo "RDS instances found: $RDS_EXISTS"
          echo "VPCs found: $VPC_EXISTS"
          echo "API Gateways found: $API_EXISTS"
          
          # If any resources exist, set the flag
          if [ "$EC2_EXISTS" -gt 0 ] || [ "$RDS_EXISTS" -gt 0 ] || [ "$VPC_EXISTS" -gt 0 ] || [ "$API_EXISTS" -gt 0 ]; then
            echo "existing_resources=true" >> $GITHUB_OUTPUT
            echo "Some resources already exist. To avoid duplicates, the deployment will be cancelled."
          else
            echo "existing_resources=false" >> $GITHUB_OUTPUT
            echo "No existing resources found. Proceeding with deployment."
          fi
          
          # Also check Terraform state as a backup check
          cd terraform
          if terraform state list | grep -q "aws_instance.hr_portal_ec2"; then
            echo "terraform_deployed=true" >> $GITHUB_OUTPUT
            # Get outputs safely with error handling
            EC2_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "unavailable")
            API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "unavailable")
            echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
            echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
          else
            echo "terraform_deployed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Cancel deployment if resources exist
        if: ${{ steps.check_resources.outputs.existing_resources == 'true' || steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          echo "Infrastructure is already deployed or resources with the same names already exist."
          if [[ "${{ steps.check_resources.outputs.terraform_deployed }}" == "true" ]]; then
            echo "EC2 Instance URL: http://${{ steps.check_resources.outputs.EC2_IP || 'unavailable' }}"
            echo "API Gateway URL: ${{ steps.check_resources.outputs.API_URL || 'unavailable' }}"
          fi
          echo "To destroy the infrastructure, run the destroy workflow."
          exit 0
          
      - name: Install dependencies
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: npm ci
        
      - name: Build application
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: npm run build
        
      - name: Terraform Plan
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform plan -var="db_username=admin" -var="db_password=password123"
        
      - name: Terraform Apply
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform apply -auto-approve -var="db_username=admin" -var="db_password=password123"
          
      - name: Deploy application to EC2
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          # Get the public IP of the EC2 instance from Terraform output
          cd terraform
          EC2_IP=$(terraform output -raw ec2_public_ip)
          API_URL=$(terraform output -raw api_gateway_url)
          
          # Package the application
          cd ..
          tar -czf app.tar.gz dist
          
          # Copy files to EC2 using scp without key verification
          scp -o StrictHostKeyChecking=no app.tar.gz ec2-user@$EC2_IP:/home/ec2-user/
          
          # SSH into the instance and deploy without key verification
          ssh -o StrictHostKeyChecking=no ec2-user@$EC2_IP << 'EOF'
            mkdir -p /var/www/html
            tar -xzf app.tar.gz -C /var/www/html
            # Create database configuration with hardcoded credentials
            echo "db_config:" > /home/ec2-user/db_config.yaml
            echo "  username: admin" >> /home/ec2-user/db_config.yaml
            echo "  password: password123" >> /home/ec2-user/db_config.yaml
            echo "  host: $(aws rds describe-db-instances --db-instance-identifier hr-portal-db --query 'DBInstances[0].Endpoint.Address' --output text)" >> /home/ec2-user/db_config.yaml
            # Setup and start the application (simplified)
            sudo systemctl restart nginx
          EOF
          
          echo "Application deployed successfully!"
          echo "EC2 Instance URL: http://$EC2_IP"
          echo "API Gateway URL: $API_URL"
      
      - name: Display URLs for existing deployment
        if: ${{ steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          echo "Application is already deployed!"
          echo "EC2 Instance URL: http://${{ steps.check_resources.outputs.EC2_IP || 'unavailable' }}"
          echo "API Gateway URL: ${{ steps.check_resources.outputs.API_URL || 'unavailable' }}"
