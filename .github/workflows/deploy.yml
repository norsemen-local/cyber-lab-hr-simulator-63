name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
      
      - name: Check for existing resources
        id: check_resources
        run: |
          cd terraform
          # Check if Terraform state file exists
          if [[ -f terraform.tfstate ]]; then
            echo "Terraform state file exists."
            TERRAFORM_DEPLOYED="true"
          else
            echo "Terraform state file does not exist."
            TERRAFORM_DEPLOYED="false"
          fi
          echo "terraform_deployed=${TERRAFORM_DEPLOYED}" >> $GITHUB_OUTPUT

          # Check if EC2 instance exists
          EC2_COUNT=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=hr-portal-ec2" --region ${{ secrets.AWS_REGION }} | jq '.Reservations | length')
          if [ "$EC2_COUNT" -gt 0 ]; then
            echo "EC2 instance exists."
            EXISTING_RESOURCES="true"
            
            # Retrieve EC2 public IP
            EC2_IP=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=hr-portal-ec2" --region ${{ secrets.AWS_REGION }} | jq '.Reservations[0].Instances[0].PublicIpAddress' | tr -d '"')
            echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
            
            # Retrieve API Gateway URL
            API_ID=$(aws apigateway get-rest-apis --region ${{ secrets.AWS_REGION }} | jq '.items[] | select(.name=="hr-portal-api") | .id' | tr -d '"')
            if [ -n "$API_ID" ]; then
              API_URL="https://$API_ID.execute-api.${{ secrets.AWS_REGION }}.amazonaws.com/prod"
              echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
            else
              echo "API Gateway not found."
            fi
            echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
            echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
          else
            echo "EC2 instance does not exist."
            EXISTING_RESOURCES="false"
          fi
          echo "existing_resources=${EXISTING_RESOURCES}" >> $GITHUB_OUTPUT
          
      - name: Cancel deployment if resources exist
        if: ${{ steps.check_resources.outputs.existing_resources == 'true' || steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          echo "Resources already exist. Cancelling deployment."
          exit 1
          
      - name: Build Docker image
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          docker build -t hr-portal-app:latest .
          docker save hr-portal-app:latest > hr-portal-app.tar
        
      - name: Terraform Plan
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform plan -var="db_username=admin" -var="db_password=password123"
        
      - name: Terraform Apply
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform apply -auto-approve -var="db_username=admin" -var="db_password=password123"
          
      - name: Deploy Docker container to EC2
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          # Get the public IP of the EC2 instance
          cd terraform
          EC2_IP=$(terraform output -raw ec2_public_ip)
          API_URL=$(terraform output -raw api_gateway_url)
          INSTANCE_ID=$(terraform state show aws_instance.hr_portal_ec2 | grep "id" | head -n 1 | awk -F= '{print $2}' | xargs)
          
          echo "EC2 IP: $EC2_IP"
          echo "Instance ID: $INSTANCE_ID"
          
          # Wait for the instance to be ready - increased wait time
          echo "Waiting for instance to be fully initialized and ready for SSM commands..."
          MAX_ATTEMPTS=40
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Checking if instance is ready..."
            
            # Check instance state
            INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].State.Name" --output text || echo "unknown")
            echo "Instance state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "Instance is not in running state. Waiting 30 seconds..."
              sleep 30
              continue
            fi
            
            # Check SSM status
            SSM_STATUS=$(aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$INSTANCE_ID" --query "InstanceInformationList[].PingStatus" --output text || echo "OFFLINE")
            echo "SSM Status: $SSM_STATUS"
            
            if [ "$SSM_STATUS" == "Online" ]; then
              echo "Instance is ready and accessible via SSM!"
              break
            fi
            
            echo "Instance is not yet available via SSM. Waiting 30 seconds..."
            sleep 30
            
            # If we've reached the last attempt and still not ready, continue anyway
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "Max attempts reached but instance is still not fully ready. Proceeding anyway..."
            fi
          done
          
          # Wait more time for the instance to fully initialize
          echo "Waiting an additional 2 minutes for instance services to fully start..."
          sleep 120
          
          # Test SSH connectivity with a simple command
          echo "Testing SSM connectivity with a simple command..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=['echo \"SSM test successful\"', 'docker --version || amazon-linux-extras install -y docker', 'systemctl status docker || systemctl start docker']" \
            --comment "Testing SSM connectivity and Docker installation" || echo "Initial SSM test failed, but continuing deployment"
          
          sleep 15
          
          # Transfer the Docker image to the EC2 instance
          echo "Transferring Docker image to EC2 instance..."
          aws s3 mb s3://hr-portal-docker-temp-$(date +%s) || echo "S3 bucket already exists"
          BUCKET_NAME=$(aws s3 ls | grep hr-portal-docker-temp | tail -n 1 | awk '{print $3}')
          aws s3 cp hr-portal-app.tar s3://$BUCKET_NAME/
          
          # Deploy Docker container
          echo "Deploying Docker container..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=[
              'echo \"Starting Docker deployment at $(date)\"',
              'aws s3 cp s3://$BUCKET_NAME/hr-portal-app.tar /tmp/',
              'docker load -i /tmp/hr-portal-app.tar',
              'docker stop hr-portal-container || true',
              'docker rm hr-portal-container || true',
              'docker run -d --name hr-portal-container -p 80:80 hr-portal-app:latest',
              'echo \"Verifying Docker container is running...\"',
              'docker ps',
              'echo \"Testing web server...\"',
              'curl -s http://localhost || echo \"Could not connect to web server\"',
              'echo \"Deployment completed at $(date)\"'
            ]" \
            --comment "Deploy HR Portal Docker container" || echo "SSM deployment command failed, but infrastructure is deployed"
          
          # Clean up S3 bucket
          aws s3 rm s3://$BUCKET_NAME/hr-portal-app.tar
          aws s3 rb s3://$BUCKET_NAME
          
          echo "Deployment process completed!"
          echo "EC2 Instance URL: http://$EC2_IP"
          echo "API Gateway URL: $API_URL"
          
          # Display information even if deployment failed
          echo "If the application deployment via SSM failed, you may need to manually check the instance status"
          echo "using AWS Console or connect to the instance once it's fully initialized."
      
      - name: Display URLs for existing deployment
        if: ${{ steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          echo "Application is already deployed!"
          echo "EC2 Instance URL: http://${{ steps.check_resources.outputs.EC2_IP || 'unavailable' }}"
          echo "API Gateway URL: ${{ steps.check_resources.outputs.API_URL || 'unavailable' }}"
