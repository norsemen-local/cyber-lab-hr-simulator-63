
name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
      
      - name: Check for existing resources
        id: check_resources
        run: |
          # ... keep existing code (resource checking logic)
          
      - name: Cancel deployment if resources exist
        if: ${{ steps.check_resources.outputs.existing_resources == 'true' || steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          # ... keep existing code (deployment cancellation logic)
          
      - name: Install dependencies
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: npm ci
        
      - name: Build application
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: npm run build
        
      - name: Terraform Plan
        if: ${{ steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform plan -var="db_username=admin" -var="db_password=password123"
        
      - name: Terraform Apply
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          cd terraform
          terraform apply -auto-approve -var="db_username=admin" -var="db_password=password123"
          
      - name: Deploy application to EC2
        if: ${{ github.ref == 'refs/heads/main' && steps.check_resources.outputs.existing_resources != 'true' && steps.check_resources.outputs.terraform_deployed != 'true' }}
        run: |
          # Get the public IP of the EC2 instance from Terraform output
          cd terraform
          EC2_IP=$(terraform output -raw ec2_public_ip)
          API_URL=$(terraform output -raw api_gateway_url)
          
          # Package the application
          cd ..
          tar -czf app.tar.gz dist
          
          # Get the instance ID directly from Terraform state
          INSTANCE_ID=$(cd terraform && terraform state show aws_instance.hr_portal_ec2 | grep "id" | head -n 1 | awk -F= '{print $2}' | xargs)
          echo "Instance ID: $INSTANCE_ID"
          
          # Wait for the instance to be ready - significantly increased wait time
          echo "Waiting for instance to be fully initialized and ready for SSM commands..."
          MAX_ATTEMPTS=30
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS: Checking if instance is ready..."
            
            # Check instance state
            INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].State.Name" --output text || echo "unknown")
            echo "Instance state: $INSTANCE_STATE"
            
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "Instance is not in running state. Waiting 30 seconds..."
              sleep 30
              continue
            fi
            
            # Check EC2 instance status checks
            STATUS_CHECKS=$(aws ec2 describe-instance-status --instance-ids $INSTANCE_ID --query "InstanceStatuses[0].InstanceStatus.Status" --output text || echo "initializing")
            echo "Instance status checks: $STATUS_CHECKS"
            
            if [ "$STATUS_CHECKS" != "ok" ]; then
              echo "Instance status checks not passed yet. Waiting 30 seconds..."
              sleep 30
              continue
            fi
            
            # Check if port 80 is open (requires netcat)
            echo "Checking if port 80 is open on instance $EC2_IP..."
            if nc -z -w5 $EC2_IP 80 2>/dev/null; then
              echo "Port 80 is OPEN on instance $EC2_IP!"
            else
              echo "Port 80 is NOT OPEN on instance $EC2_IP. Waiting 30 seconds..."
              sleep 30
              continue
            fi
            
            # Check SSM status
            SSM_STATUS=$(aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$INSTANCE_ID" --query "InstanceInformationList[].PingStatus" --output text || echo "OFFLINE")
            echo "SSM Status: $SSM_STATUS"
            
            if [ "$SSM_STATUS" == "Online" ]; then
              echo "Instance is ready and accessible via SSM!"
              break
            fi
            
            echo "Instance is not yet available via SSM. Waiting 30 seconds..."
            sleep 30
            
            # If we've reached the last attempt and still not ready, continue anyway
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "Max attempts reached but instance is still not fully ready. Proceeding anyway..."
            fi
          done
          
          # Try a simple SSM command first to verify connectivity with extended timeout
          echo "Testing SSM connectivity with a simple command..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=['echo \"SSM test successful\"']" \
            --comment "Testing SSM connectivity" || echo "Initial SSM test failed, but continuing deployment"
          
          # Wait a bit more to ensure the command had time to process
          sleep 15
          
          # Verify Nginx is running using SSM
          echo "Verifying Nginx status via SSM..."
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=['systemctl status nginx', 'ss -tunlp | grep :80', 'curl -s http://localhost']" \
            --comment "Checking Nginx status" || echo "Nginx status check failed, but continuing deployment"
          
          sleep 15
          
          # Deploy web content regardless of SSM status
          echo "Deploying application content..."
          # Try to use SSM to deploy the application
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=InstanceIds,Values=$INSTANCE_ID" \
            --parameters "commands=[
              'echo \"Starting deployment at $(date)\"',
              'mkdir -p /var/www/html', 
              'echo \"<!DOCTYPE html><html><head><title>HR Portal - GitHub Actions Deployment</title><style>body{font-family:Arial,sans-serif;margin:0;padding:0;display:flex;justify-content:center;align-items:center;height:100vh;text-align:center;background-color:#f5f5f5;}h1{color:#4CAF50;}p{margin:20px 0;}</style></head><body><h1>HR Portal Deployment Success!</h1><p>Application deployed via GitHub Actions at $(date)</p></body></html>\" > /var/www/html/index.html', 
              'chmod -R 755 /var/www/html', 
              'chown -R nginx:nginx /var/www/html || true',
              'systemctl restart nginx',
              'systemctl status nginx',
              'ss -tunlp | grep :80',
              'echo \"Deployment completed at $(date)\"'
            ]" \
            --comment "Deploy HR Portal application" || echo "SSM deployment command failed, but infrastructure is deployed"
          
          echo "Deployment process completed!"
          echo "EC2 Instance URL: http://$EC2_IP"
          echo "API Gateway URL: $API_URL"
          
          # Display information even if deployment failed
          echo "If the application deployment via SSM failed, you may need to manually check the instance status"
          echo "using AWS Console or connect to the instance once it's fully initialized."
      
      - name: Display URLs for existing deployment
        if: ${{ steps.check_resources.outputs.terraform_deployed == 'true' }}
        run: |
          echo "Application is already deployed!"
          echo "EC2 Instance URL: http://${{ steps.check_resources.outputs.EC2_IP || 'unavailable' }}"
          echo "API Gateway URL: ${{ steps.check_resources.outputs.API_URL || 'unavailable' }}"
